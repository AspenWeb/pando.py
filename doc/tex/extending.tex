\chapter{Extending Aspen \label{extending}}

Aspen uses Python's WSGI specification for its extension architecture. There are
three categories of extension:

\begin{tableii}{l|l}{}{Category}{Explanation}
\lineii{applications}{applications are connected to directories within the site
    hierarchy; only one app touches any given request}
\lineii{handlers}{handlers are tied to individual resources (i.e., files) based
    on extensible rules; only one handler touches any given request}
\lineii{middleware}{one or many middleware applications may be specified;
    all middleware generally touches every request}
\end{tableii}

All extensions are WSGI callables, connected to the above entry points with
three configuration files in \file{__/etc}:

\begin{itemize}
\item{\file{apps.conf}}
\item{\file{handlers.conf}}
\item{\file{middleware.conf}}
\end{itemize}

Where called for in these files, objects are specified in a notation derived
from setuptools' entry_points feature: a dotted module name, followed by a colon
and a dotted identifier naming an object within the module. This is referred to
below as \dfn{colon notation}. The following example would import the \code{bar}
object from \code{example.package.foo}, and use its \code{baz} attribute (a WSGI
callable):

\begin{verbatim}
example.package.foo:bar.baz
\end{verbatim}

For applications and handlers, when names in colon notation point to a class,
Aspen attempts to instantiate the class with the current \class{Website}
instance as its sole positional argument. Failing this, Aspen instantiates the
class without any arguments. The instance is then used as the named object. At
run-time, applications and handlers can also access the \class{Website} instance
at \code{environ['aspen.website']}.

Middleware constructors are always called with one positional argument, which is
the next middleware on the stack.

The comment character for these files is \#, and comments can be included
in-line. Blank lines are ignored, as is initial and trailing whitespace
per-line. Where section names are called for, they are given in brackets.


\section{Applications: Path-based Extension \label{apps}}

In Aspen, an \dfn{application} or \dfn{app} refers to a WSGI application that is
connected to a particular directory. Apps are set up in \file{__/etc/apps.conf}.

The \file{__/etc/apps.conf} file contains a newline-separated list of
white-space-separated path name/object name pairs. The path names refer to
URL-space, and are translated literally to the filesystem. If the trailing slash
is given, then requests for that directory will first be redirected to the
trailing slash before being handed off to the application. If no trailing slash
is given, the application will also get requests without the slash. When
choosing an application to service a request, the most specific pathname matches
first.

Object names are in colon notation, and they name WSGI callables.

Aspen will (over)write a file called \file{README.aspen} in each directory
mentioned in \file{apps.conf}, containing the relevant line from
\file{apps.conf}. If the directory does not exist, it is created. Aspen will
also remove any obsolete \file{README.aspen} files within your site tree.


\subsection{Example apps.conf}

\begin{verbatim}
/foo        example.apps:foo    # will get both /foo and /foo/
/bar/       example.apps:bar    # /bar will redirect to /bar/
/bar/baz    example.apps:baz    # will 'steal' some of /bar's requests
\end{verbatim}


\section{Handlers: Resource-based Extension \label{handlers}}

Aspen \dfn{handlers} are WSGI applications that are associated with files and
directories on the filesystem according to arbitrary rules. This provides a
flexible infrastructure for many different development patterns.

The \file{__/etc/handlers.conf} file begins with an anonymous "rules" section,
which is a newline-separated list of white-space-separated rule name/object name
pairs. Rule names can be any string without whitespace. Each object name (in
colon notation) specifies a \dfn{rule}, a callable taking a filesystem path name
and an arbitrary predicate string, and returning \class{True} or \class{False}.

Following the rule specification are sections specifying \dfn{handlers}, which
as mentioned above are WSGI callables.

The name of each section specifies a handler (a WSGI callable) in colon
notation. The body of each section is a newline-separated list of conditions
under which this handler is to be called. Fundamentally, these conditions are
made up of a rule name as defined at the beginning of the file, and an arbitrary
predicate string (which can include whitespace) that is meaningful to the
matching rule callable. If no predicate is given, then the rule callable will
receive \class{None} for its predicate argument. Rules must be explicitly
specified at the beginning of the file before being available within handler
sections. After the first condition in a handler section, additional condition
lines must begin with one of \code{AND}, \code{OR}, or \code{NOT}. These
case-insensitive tokens specify how conditions are to be combined in evaluating
whether to use this handler.

On each request, handlers are considered in the order given, and the first
matching handler is used. Only one handler is used for any given request.

Note that if the file \file{__/etc/handlers.conf} exists at all, the defaults
(see the example below) disappear, and you must respecify any of the default
rules in your own file if you want them.


\subsection{Example handlers.conf}
This is Aspen's default handler configuration:

\begin{verbatim}
catch_all   aspen.rules:catch_all
isdir       aspen.rules:isdir
isfile      aspen.rules:isfile
fnmatch     aspen.rules:fnmatch
hashbang    aspen.rules:hashbang


[aspen.handlers:HTTP404]
      isfile
  AND fnmatch *.py[cod]         # hide any compiled Python scripts

[aspen.handlers:pyscript]
      isfile
  AND fnmatch *.py              # exec python scripts ...
  OR  hashbang                  # ... and anything starting with #!

[aspen.handlers:default_or_autoindex]
  isdir                         # do smart things for directories

[aspen.handlers:static]
  catch_all                     # anything else, serve it statically
\end{verbatim}


\section{Middleware: Global Extension \label{middleware}}

Aspen allows for a full WSGI middleware stack, configured via the
\file{__/etc/middleware.conf} file. This is simply a newline-separated list of
middleware specifiers in colon notation. The first-mentioned middleware will be
the outer-most in the stack (i.e., closest to the browser).

\subsection{Example middleware.conf}

\begin{verbatim}
example.foo:bar # called as is
example.baz:Buz # will be instantiated
\end{verbatim}